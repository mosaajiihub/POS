import { describe, it, expect, beforeEach, vi } from 'vitest'
import { VulnerabilityService, VulnerabilityStatus } from '../services/vulnerabilityService'
import * as fs from 'fs'
import * as path from 'path'

// Mock dependencies
vi.mock('fs')
vi.mock('../utils/logger')
vi.mock('../services/auditService')

describe('VulnerabilityService', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('scanDependencies', () => {
    it('should return error when no package.json files found', async () => {
      // Mock fs.readdirSync to return empty array
      vi.mocked(fs.readdirSync).mockReturnValue([])
      vi.mocked(fs.statSync).mockReturnValue({ isDirectory: () => false } as any)

      const result = await VulnerabilityService.scanDependencies('/test/path')

      expect(result.success).toBe(false)
      expect(result.message).toBe('No package.json files found')
      expect(result.errors).toContain('No dependency files detected in the project')
    })

    it('should handle scan errors gracefully', async () => {
      // Mock fs operations to throw error
      vi.mocked(fs.readdirSync).mockImplementation(() => {
        throw new Error('Permission denied')
      })

      const result = await VulnerabilityService.scanDependencies('/test/path')

      expect(result.success).toBe(false)
      expect(result.message).toBe('Dependency vulnerability scan failed')
      expect(result.errors).toBeDefined()
    })

    it('should successfully scan when package.json exists', async () => {
      // Mock finding package.json file
      vi.mocked(fs.readdirSync).mockReturnValue(['package.json'] as any)
      vi.mocked(fs.statSync).mockReturnValue({ isDirectory: () => false } as any)
      vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({
        dependencies: { 'test-package': '^1.0.0' }
      }))

      // Mock npm audit command
      const mockExec = vi.fn().mockResolvedValue({
        stdout: JSON.stringify({
          vulnerabilities: {
            'test-package': {
              version: '1.0.0',
              via: [{
                title: 'Test vulnerability',
                severity: 'high',
                cve: 'CVE-2023-1234'
              }]
            }
          }
        })
      })

      // Mock child_process
      vi.doMock('child_process', () => ({
        exec: mockExec
      }))
      vi.doMock('util', () => ({
        promisify: (fn: any) => fn
      }))

      const result = await VulnerabilityService.scanDependencies('/test/path')

      expect(result.success).toBe(true)
      expect(result.report).toBeDefined()
      expect(result.report?.totalVulnerabilities).toBeGreaterThan(0)
    })
  })

  describe('updateVulnerabilityStatus', () => {
    it('should successfully update vulnerability status', async () => {
      const result = await VulnerabilityService.updateVulnerabilityStatus(
        'test-vuln-id',
        VulnerabilityStatus.FIXED,
        'test-user',
        'Fixed by updating dependency'
      )

      expect(result).toBe(true)
    })

    it('should handle update errors', async () => {
      // Mock AuditService to throw error
      const { AuditService } = await import('../services/auditService')
      vi.mocked(AuditService.createAuditLog).mockRejectedValue(new Error('Database error'))

      const result = await VulnerabilityService.updateVulnerabilityStatus(
        'test-vuln-id',
        VulnerabilityStatus.FIXED,
        'test-user'
      )

      expect(result).toBe(false)
    })
  })

  describe('getVulnerabilityStats', () => {
    it('should return default stats when no data available', async () => {
      const stats = await VulnerabilityService.getVulnerabilityStats(30)

      expect(stats).toEqual({
        totalScans: 0,
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        fixedCount: 0,
        openCount: 0,
        averageRiskScore: 0
      })
    })
  })

  describe('scheduleAutomatedScan', () => {
    it('should successfully schedule automated scan', async () => {
      // Mock node-cron
      const mockSchedule = vi.fn()
      vi.doMock('node-cron', () => ({
        schedule: mockSchedule
      }))

      const result = await VulnerabilityService.scheduleAutomatedScan('0 2 * * *')

      expect(result).toBe(true)
    })

    it('should handle scheduling errors', async () => {
      // Mock node-cron to throw error
      vi.doMock('node-cron', () => ({
        schedule: () => {
          throw new Error('Invalid cron expression')
        }
      }))

      const result = await VulnerabilityService.scheduleAutomatedScan('invalid-cron')

      expect(result).toBe(false)
    })
  })

  describe('trackRemediation', () => {
    it('should return remediation status', async () => {
      const status = await VulnerabilityService.trackRemediation('test-vuln-id')

      expect(status).toBeDefined()
      expect(status?.vulnerabilityId).toBe('test-vuln-id')
      expect(status?.status).toBe(VulnerabilityStatus.OPEN)
      expect(status?.progress).toBe(0)
    })
  })

  describe('getVulnerability', () => {
    it('should return null for non-existent vulnerability', async () => {
      const vulnerability = await VulnerabilityService.getVulnerability('non-existent-id')

      expect(vulnerability).toBeNull()
    })
  })
})