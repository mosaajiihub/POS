import * as fs from 'fs'
import * as path from 'path'
import axios from 'axios'
import { logger } from '../utils/logger'
import { AuditService } from './auditService'

export interface Vulnerability {
  id: string
  cveId?: string
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
  title: string
  description: string
  affectedComponent: string
  version: string
  fixVersion?: string
  exploitability: number
  impact: number
  discoveredAt: Date
  status: VulnerabilityStatus
  remediationSteps: RemediationStep[]
  source: 'NPM_AUDIT' | 'SNYK' | 'GITHUB' | 'NVD' | 'MANUAL'
}

export interface RemediationStep {
  id: string
  description: string
  priority: 'HIGH' | 'MEDIUM' | 'LOW'
  estimatedEffort: string
  automated: boolean
  command?: string
}

export interface VulnerabilityReport {
  scanId: string
  timestamp: Date
  scanType: 'DEPENDENCY' | 'CONTAINER' | 'INFRASTRUCTURE'
  totalVulnerabilities: number
  criticalCount: number
  highCount: number
  mediumCount: number
  lowCount: number
  vulnerabilities: Vulnerability[]
  summary: VulnerabilitySummary
  recommendations: string[]
}

export interface VulnerabilitySummary {
  riskScore: number
  complianceStatus: 'COMPLIANT' | 'NON_COMPLIANT' | 'NEEDS_REVIEW'
  blockerVulnerabilities: number
  fixableVulnerabilities: number
  unfixableVulnerabilities: number
}

export interface ScanResult {
  success: boolean
  message: string
  report?: VulnerabilityReport
  errors?: string[]
}

export interface RemediationStatus {
  vulnerabilityId: string
  status: VulnerabilityStatus
  assignedTo?: string
  dueDate?: Date
  progress: number
  notes: string[]
  lastUpdated: Date
}

export enum VulnerabilityStatus {
  OPEN = 'OPEN',
  IN_PROGRESS = 'IN_PROGRESS',
  FIXED = 'FIXED',
  ACCEPTED_RISK = 'ACCEPTED_RISK',
  FALSE_POSITIVE = 'FALSE_POSITIVE',
  WONT_FIX = 'WONT_FIX'
}

/**
 * Vulnerability Management Service
 * Handles dependency scanning, vulnerability tracking, and remediation management
 */
export class VulnerabilityService {
  private static readonly VULNERABILITY_DB_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
  private static readonly GITHUB_ADVISORY_URL = 'https://api.github.com/advisories'
  private static readonly SCAN_CACHE_DURATION = 24 * 60 * 60 * 1000 // 24 hours

  /**
   * Scan dependencies for vulnerabilities
   */
  static async scanDependencies(projectPath: string = process.cwd()): Promise<ScanResult> {
    try {
      const scanId = `dep_scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      logger.info(`Starting dependency vulnerability scan: ${scanId}`)

      // Check for package.json files
      const packageFiles = await this.findPackageFiles(projectPath)
      if (packageFiles.length === 0) {
        return {
          success: false,
          message: 'No package.json files found',
          errors: ['No dependency files detected in the project']
        }
      }

      const allVulnerabilities: Vulnerability[] = []
      const errors: string[] = []

      // Scan each package.json file
      for (const packageFile of packageFiles) {
        try {
          const vulnerabilities = await this.scanPackageFile(packageFile)
          allVulnerabilities.push(...vulnerabilities)
        } catch (error) {
          const errorMsg = `Failed to scan ${packageFile}: ${error instanceof Error ? error.message : 'Unknown error'}`
          errors.push(errorMsg)
          logger.error(errorMsg)
        }
      }

      // Generate report
      const report = this.generateVulnerabilityReport(scanId, allVulnerabilities, 'DEPENDENCY')

      // Store scan results
      await this.storeScanResults(report)

      // Log scan completion
      await AuditService.createAuditLog({
        userId: 'system',
        action: 'VULNERABILITY_SCAN_COMPLETED',
        tableName: 'vulnerability_scans',
        recordId: scanId,
        newValues: {
          scanType: 'DEPENDENCY',
          totalVulnerabilities: report.totalVulnerabilities,
          criticalCount: report.criticalCount,
          highCount: report.highCount,
          packageFiles: packageFiles.length,
          riskScore: report.summary.riskScore
        }
      })

      return {
        success: true,
        message: `Dependency scan completed. Found ${report.totalVulnerabilities} vulnerabilities.`,
        report,
        errors: errors.length > 0 ? errors : undefined
      }
    } catch (error) {
      logger.error('Dependency scan failed:', error)
      return {
        success: false,
        message: 'Dependency vulnerability scan failed',
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }

  /**
   * Run npm audit and parse results
   */
  private static async runNpmAudit(packageDir: string): Promise<any> {
    try {
      const { exec } = require('child_process')
      const { promisify } = require('util')
      const execAsync = promisify(exec)

      // Run npm audit with JSON output
      const { stdout } = await execAsync('npm audit --json', { 
        cwd: packageDir,
        timeout: 30000 // 30 second timeout
      })

      return JSON.parse(stdout)
    } catch (error: any) {
      // npm audit returns non-zero exit code when vulnerabilities are found
      if (error.stdout) {
        try {
          return JSON.parse(error.stdout)
        } catch (parseError) {
          throw new Error(`Failed to parse npm audit output: ${parseError}`)
        }
      }
      throw error
    }
  }

  /**
   * Scan a specific package.json file
   */
  private static async scanPackageFile(packageFilePath: string): Promise<Vulnerability[]> {
    const packageDir = path.dirname(packageFilePath)
    const vulnerabilities: Vulnerability[] = []

    try {
      // Read package.json
      const packageJson = JSON.parse(fs.readFileSync(packageFilePath, 'utf8'))
      const dependencies = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      }

      // Run npm audit
      const auditResult = await this.runNpmAudit(packageDir)

      if (auditResult.vulnerabilities) {
        // Parse npm audit results
        for (const [packageName, vulnData] of Object.entries(auditResult.vulnerabilities)) {
          const vulnInfo = vulnData as any
          
          if (vulnInfo.via && Array.isArray(vulnInfo.via)) {
            for (const via of vulnInfo.via) {
              if (typeof via === 'object' && via.title) {
                const vulnerability: Vulnerability = {
                  id: `npm_${packageName}_${via.cwe || Date.now()}`,
                  cveId: via.cve,
                  severity: this.mapSeverity(via.severity),
                  title: via.title,
                  description: via.title,
                  affectedComponent: packageName,
                  version: vulnInfo.version || dependencies[packageName] || 'unknown',
                  fixVersion: vulnInfo.fixAvailable ? 'available' : undefined,
                  exploitability: this.calculateExploitability(via.severity),
                  impact: this.calculateImpact(via.severity),
                  discoveredAt: new Date(),
                  status: VulnerabilityStatus.OPEN,
                  remediationSteps: this.generateRemediationSteps(packageName, vulnInfo),
                  source: 'NPM_AUDIT'
                }
                vulnerabilities.push(vulnerability)
              }
            }
          }
        }
      }

      // Enhance with additional vulnerability data
      await this.enhanceVulnerabilities(vulnerabilities)

      return vulnerabilities
    } catch (error) {
      logger.error(`Failed to scan package file ${packageFilePath}:`, error)
      throw error
    }
  }

  /**
   * Find all package.json files in the project
   */
  private static async findPackageFiles(projectPath: string): Promise<string[]> {
    const packageFiles: string[] = []

    const searchDir = (dir: string) => {
      try {
        const items = fs.readdirSync(dir)
        
        for (const item of items) {
          const fullPath = path.join(dir, item)
          const stat = fs.statSync(fullPath)

          if (stat.isDirectory()) {
            // Skip node_modules and other common directories
            if (!['node_modules', '.git', 'dist', 'build', '.next'].includes(item)) {
              searchDir(fullPath)
            }
          } else if (item === 'package.json') {
            packageFiles.push(fullPath)
          }
        }
      } catch (error) {
        // Ignore permission errors
      }
    }

    searchDir(projectPath)
    return packageFiles
  }

  /**
   * Enhance vulnerabilities with additional data from external sources
   */
  private static async enhanceVulnerabilities(vulnerabilities: Vulnerability[]): Promise<void> {
    for (const vuln of vulnerabilities) {
      try {
        // Try to get additional information from GitHub Advisory Database
        if (vuln.cveId) {
          const advisoryData = await this.getGitHubAdvisory(vuln.cveId)
          if (advisoryData) {
            vuln.description = advisoryData.description || vuln.description
            if (advisoryData.severity) {
              vuln.severity = this.mapSeverity(advisoryData.severity)
            }
          }
        }
      } catch (error) {
        // Continue if enhancement fails
        logger.debug(`Failed to enhance vulnerability ${vuln.id}:`, error)
      }
    }
  }

  /**
   * Get vulnerability information from GitHub Advisory Database
   */
  private static async getGitHubAdvisory(cveId: string): Promise<any> {
    try {
      const response = await axios.get(`${this.GITHUB_ADVISORY_URL}`, {
        params: {
          cve_id: cveId,
          per_page: 1
        },
        timeout: 5000
      })

      return response.data[0] || null
    } catch (error) {
      logger.debug(`Failed to fetch GitHub advisory for ${cveId}:`, error)
      return null
    }
  }

  /**
   * Generate vulnerability report
   */
  private static generateVulnerabilityReport(
    scanId: string,
    vulnerabilities: Vulnerability[],
    scanType: 'DEPENDENCY' | 'CONTAINER' | 'INFRASTRUCTURE'
  ): VulnerabilityReport {
    const criticalCount = vulnerabilities.filter(v => v.severity === 'CRITICAL').length
    const highCount = vulnerabilities.filter(v => v.severity === 'HIGH').length
    const mediumCount = vulnerabilities.filter(v => v.severity === 'MEDIUM').length
    const lowCount = vulnerabilities.filter(v => v.severity === 'LOW').length

    const riskScore = this.calculateRiskScore(vulnerabilities)
    const blockerVulnerabilities = criticalCount + highCount
    const fixableVulnerabilities = vulnerabilities.filter(v => v.fixVersion).length

    const summary: VulnerabilitySummary = {
      riskScore,
      complianceStatus: criticalCount > 0 ? 'NON_COMPLIANT' : 
                       highCount > 5 ? 'NEEDS_REVIEW' : 'COMPLIANT',
      blockerVulnerabilities,
      fixableVulnerabilities,
      unfixableVulnerabilities: vulnerabilities.length - fixableVulnerabilities
    }

    const recommendations = this.generateRecommendations(vulnerabilities, summary)

    return {
      scanId,
      timestamp: new Date(),
      scanType,
      totalVulnerabilities: vulnerabilities.length,
      criticalCount,
      highCount,
      mediumCount,
      lowCount,
      vulnerabilities,
      summary,
      recommendations
    }
  }

  /**
   * Calculate risk score based on vulnerabilities
   */
  private static calculateRiskScore(vulnerabilities: Vulnerability[]): number {
    let score = 0
    
    for (const vuln of vulnerabilities) {
      switch (vuln.severity) {
        case 'CRITICAL':
          score += 10
          break
        case 'HIGH':
          score += 7
          break
        case 'MEDIUM':
          score += 4
          break
        case 'LOW':
          score += 1
          break
      }
    }

    // Normalize to 0-100 scale
    return Math.min(100, score)
  }

  /**
   * Generate recommendations based on scan results
   */
  private static generateRecommendations(
    vulnerabilities: Vulnerability[],
    summary: VulnerabilitySummary
  ): string[] {
    const recommendations: string[] = []

    if (summary.criticalCount > 0) {
      recommendations.push(`Immediately address ${summary.criticalCount} critical vulnerabilities`)
    }

    if (summary.highCount > 0) {
      recommendations.push(`Prioritize fixing ${summary.highCount} high-severity vulnerabilities`)
    }

    if (summary.fixableVulnerabilities > 0) {
      recommendations.push(`${summary.fixableVulnerabilities} vulnerabilities have available fixes - run 'npm audit fix'`)
    }

    if (summary.unfixableVulnerabilities > 0) {
      recommendations.push(`${summary.unfixableVulnerabilities} vulnerabilities require manual intervention`)
    }

    if (summary.riskScore > 50) {
      recommendations.push('Consider implementing additional security controls due to high risk score')
    }

    return recommendations
  }

  /**
   * Generate remediation steps for a vulnerability
   */
  private static generateRemediationSteps(packageName: string, vulnInfo: any): RemediationStep[] {
    const steps: RemediationStep[] = []

    if (vulnInfo.fixAvailable) {
      steps.push({
        id: `fix_${packageName}_${Date.now()}`,
        description: `Update ${packageName} to a secure version`,
        priority: 'HIGH',
        estimatedEffort: '5-15 minutes',
        automated: true,
        command: vulnInfo.fixAvailable === true ? 'npm audit fix' : `npm install ${packageName}@${vulnInfo.fixAvailable}`
      })
    } else {
      steps.push({
        id: `manual_${packageName}_${Date.now()}`,
        description: `Manually review and replace ${packageName} with a secure alternative`,
        priority: 'HIGH',
        estimatedEffort: '1-4 hours',
        automated: false
      })
    }

    steps.push({
      id: `monitor_${packageName}_${Date.now()}`,
      description: `Monitor ${packageName} for security updates`,
      priority: 'MEDIUM',
      estimatedEffort: 'Ongoing',
      automated: false
    })

    return steps
  }

  /**
   * Map severity levels
   */
  private static mapSeverity(severity: string): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
    const normalizedSeverity = severity.toUpperCase()
    
    switch (normalizedSeverity) {
      case 'CRITICAL':
        return 'CRITICAL'
      case 'HIGH':
        return 'HIGH'
      case 'MODERATE':
      case 'MEDIUM':
        return 'MEDIUM'
      case 'LOW':
      case 'INFO':
        return 'LOW'
      default:
        return 'MEDIUM'
    }
  }

  /**
   * Calculate exploitability score
   */
  private static calculateExploitability(severity: string): number {
    switch (severity.toUpperCase()) {
      case 'CRITICAL':
        return 9.5
      case 'HIGH':
        return 7.5
      case 'MEDIUM':
        return 5.0
      case 'LOW':
        return 2.5
      default:
        return 5.0
    }
  }

  /**
   * Calculate impact score
   */
  private static calculateImpact(severity: string): number {
    switch (severity.toUpperCase()) {
      case 'CRITICAL':
        return 9.0
      case 'HIGH':
        return 7.0
      case 'MEDIUM':
        return 5.0
      case 'LOW':
        return 3.0
      default:
        return 5.0
    }
  }

  /**
   * Store scan results
   */
  private static async storeScanResults(report: VulnerabilityReport): Promise<void> {
    try {
      // In a real implementation, store in database
      // For now, log the results
      logger.info(`Vulnerability scan ${report.scanId} completed:`, {
        totalVulnerabilities: report.totalVulnerabilities,
        criticalCount: report.criticalCount,
        highCount: report.highCount,
        riskScore: report.summary.riskScore,
        complianceStatus: report.summary.complianceStatus
      })

      // Store in audit log
      await AuditService.createAuditLog({
        userId: 'system',
        action: 'VULNERABILITY_SCAN_STORED',
        tableName: 'vulnerability_reports',
        recordId: report.scanId,
        newValues: {
          scanType: report.scanType,
          summary: report.summary,
          vulnerabilityCount: report.totalVulnerabilities
        }
      })
    } catch (error) {
      logger.error('Failed to store scan results:', error)
    }
  }

  /**
   * Get vulnerability by ID
   */
  static async getVulnerability(vulnerabilityId: string): Promise<Vulnerability | null> {
    try {
      // In a real implementation, retrieve from database
      // For now, return null as placeholder
      return null
    } catch (error) {
      logger.error(`Failed to get vulnerability ${vulnerabilityId}:`, error)
      return null
    }
  }

  /**
   * Update vulnerability status
   */
  static async updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: VulnerabilityStatus,
    updatedBy: string,
    notes?: string
  ): Promise<boolean> {
    try {
      // In a real implementation, update database
      
      // Log status update
      await AuditService.createAuditLog({
        userId: updatedBy,
        action: 'VULNERABILITY_STATUS_UPDATED',
        tableName: 'vulnerabilities',
        recordId: vulnerabilityId,
        newValues: {
          status,
          notes,
          updatedAt: new Date().toISOString()
        }
      })

      logger.info(`Vulnerability ${vulnerabilityId} status updated to ${status} by ${updatedBy}`)
      return true
    } catch (error) {
      logger.error(`Failed to update vulnerability status:`, error)
      return false
    }
  }

  /**
   * Track remediation progress
   */
  static async trackRemediation(vulnerabilityId: string): Promise<RemediationStatus | null> {
    try {
      // In a real implementation, retrieve from database
      // For now, return placeholder
      return {
        vulnerabilityId,
        status: VulnerabilityStatus.OPEN,
        progress: 0,
        notes: [],
        lastUpdated: new Date()
      }
    } catch (error) {
      logger.error(`Failed to track remediation for ${vulnerabilityId}:`, error)
      return null
    }
  }

  /**
   * Get vulnerability statistics
   */
  static async getVulnerabilityStats(days: number = 30): Promise<{
    totalScans: number
    totalVulnerabilities: number
    criticalCount: number
    highCount: number
    mediumCount: number
    lowCount: number
    fixedCount: number
    openCount: number
    averageRiskScore: number
  }> {
    try {
      // In a real implementation, query database for statistics
      // For now, return placeholder data
      return {
        totalScans: 0,
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        fixedCount: 0,
        openCount: 0,
        averageRiskScore: 0
      }
    } catch (error) {
      logger.error('Failed to get vulnerability statistics:', error)
      throw error
    }
  }

  /**
   * Schedule automated vulnerability scan
   */
  static async scheduleAutomatedScan(cronExpression: string = '0 2 * * *'): Promise<boolean> {
    try {
      const cron = require('node-cron')
      
      // Schedule daily scan at 2 AM
      cron.schedule(cronExpression, async () => {
        logger.info('Starting scheduled vulnerability scan...')
        
        try {
          const result = await this.scanDependencies()
          
          if (result.success && result.report) {
            // Send alerts for critical vulnerabilities
            if (result.report.criticalCount > 0 || result.report.highCount > 5) {
              await this.sendVulnerabilityAlert(result.report)
            }
          }
        } catch (error) {
          logger.error('Scheduled vulnerability scan failed:', error)
        }
      })

      logger.info(`Automated vulnerability scanning scheduled with cron: ${cronExpression}`)
      return true
    } catch (error) {
      logger.error('Failed to schedule automated scan:', error)
      return false
    }
  }

  /**
   * Send vulnerability alert
   */
  private static async sendVulnerabilityAlert(report: VulnerabilityReport): Promise<void> {
    try {
      const alertMessage = `Vulnerability Scan Alert: Found ${report.criticalCount} critical and ${report.highCount} high-severity vulnerabilities. Risk Score: ${report.summary.riskScore}`

      // Log alert
      await AuditService.createAuditLog({
        userId: 'system',
        action: 'VULNERABILITY_ALERT_SENT',
        tableName: 'vulnerability_alerts',
        recordId: report.scanId,
        newValues: {
          alertMessage,
          criticalCount: report.criticalCount,
          highCount: report.highCount,
          riskScore: report.summary.riskScore
        }
      })

      logger.warn(alertMessage)
      
      // In a real implementation, send email/SMS notifications
    } catch (error) {
      logger.error('Failed to send vulnerability alert:', error)
    }
  }
}