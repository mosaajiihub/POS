import { Request, Response } from 'express'
import { logger } from '../utils/logger'
import { VulnerabilityService, VulnerabilityStatus } from '../services/vulnerabilityService'
import { CICDSecurityService } from '../services/cicdSecurityService'
import { ContainerSecurityService } from '../services/containerSecurityService'

/**
 * Vulnerability Management Controller
 * Handles API endpoints for vulnerability scanning and management
 */
export class VulnerabilityController {
  /**
   * Scan dependencies for vulnerabilities
   */
  static async scanDependencies(req: Request, res: Response): Promise<void> {
    try {
      const { projectPath } = req.body
      
      logger.info('Starting dependency vulnerability scan', { 
        userId: req.user?.id,
        projectPath 
      })

      const result = await VulnerabilityService.scanDependencies(projectPath)

      if (result.success) {
        res.status(200).json({
          success: true,
          message: result.message,
          data: {
            report: result.report,
            errors: result.errors
          }
        })
      } else {
        res.status(400).json({
          success: false,
          message: result.message,
          errors: result.errors
        })
      }
    } catch (error) {
      logger.error('Dependency scan endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error during dependency scan',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Get vulnerability by ID
   */
  static async getVulnerability(req: Request, res: Response): Promise<void> {
    try {
      const { vulnerabilityId } = req.params

      const vulnerability = await VulnerabilityService.getVulnerability(vulnerabilityId)

      if (vulnerability) {
        res.status(200).json({
          success: true,
          data: vulnerability
        })
      } else {
        res.status(404).json({
          success: false,
          message: 'Vulnerability not found'
        })
      }
    } catch (error) {
      logger.error('Get vulnerability endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Update vulnerability status
   */
  static async updateVulnerabilityStatus(req: Request, res: Response): Promise<void> {
    try {
      const { vulnerabilityId } = req.params
      const { status, notes } = req.body
      const userId = req.user?.id || 'unknown'

      // Validate status
      if (!Object.values(VulnerabilityStatus).includes(status)) {
        res.status(400).json({
          success: false,
          message: 'Invalid vulnerability status'
        })
        return
      }

      const success = await VulnerabilityService.updateVulnerabilityStatus(
        vulnerabilityId,
        status,
        userId,
        notes
      )

      if (success) {
        res.status(200).json({
          success: true,
          message: 'Vulnerability status updated successfully'
        })
      } else {
        res.status(400).json({
          success: false,
          message: 'Failed to update vulnerability status'
        })
      }
    } catch (error) {
      logger.error('Update vulnerability status endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Track remediation progress
   */
  static async trackRemediation(req: Request, res: Response): Promise<void> {
    try {
      const { vulnerabilityId } = req.params

      const remediationStatus = await VulnerabilityService.trackRemediation(vulnerabilityId)

      if (remediationStatus) {
        res.status(200).json({
          success: true,
          data: remediationStatus
        })
      } else {
        res.status(404).json({
          success: false,
          message: 'Remediation tracking not found'
        })
      }
    } catch (error) {
      logger.error('Track remediation endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Get vulnerability statistics
   */
  static async getVulnerabilityStats(req: Request, res: Response): Promise<void> {
    try {
      const { days = 30 } = req.query
      const daysNumber = parseInt(days as string, 10)

      const stats = await VulnerabilityService.getVulnerabilityStats(daysNumber)

      res.status(200).json({
        success: true,
        data: stats
      })
    } catch (error) {
      logger.error('Get vulnerability stats endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Validate CI/CD security gates
   */
  static async validateSecurityGates(req: Request, res: Response): Promise<void> {
    try {
      const pipeline = req.body

      logger.info('Validating CI/CD security gates', { 
        userId: req.user?.id,
        pipelineId: pipeline.id 
      })

      const result = await CICDSecurityService.validateSecurityGates(pipeline)

      res.status(200).json({
        success: true,
        data: result
      })
    } catch (error) {
      logger.error('Validate security gates endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error during security gate validation',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Check if deployment should be blocked
   */
  static async checkDeploymentBlocking(req: Request, res: Response): Promise<void> {
    try {
      const { vulnerabilities } = req.body

      const shouldBlock = await CICDSecurityService.blockInsecureDeployment(vulnerabilities)

      res.status(200).json({
        success: true,
        data: {
          shouldBlock,
          message: shouldBlock ? 
            'Deployment blocked due to critical security vulnerabilities' : 
            'Deployment approved - no blocking vulnerabilities found'
        }
      })
    } catch (error) {
      logger.error('Check deployment blocking endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Generate security artifacts
   */
  static async generateSecurityArtifacts(req: Request, res: Response): Promise<void> {
    try {
      const buildInfo = req.body

      logger.info('Generating security artifacts', { 
        userId: req.user?.id,
        buildId: buildInfo.buildId 
      })

      const artifacts = await CICDSecurityService.generateSecurityArtifacts(buildInfo)

      res.status(200).json({
        success: true,
        data: {
          artifacts,
          message: `Generated ${artifacts.length} security artifacts`
        }
      })
    } catch (error) {
      logger.error('Generate security artifacts endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error during artifact generation',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Scan container image
   */
  static async scanContainerImage(req: Request, res: Response): Promise<void> {
    try {
      const { imageId } = req.body

      if (!imageId) {
        res.status(400).json({
          success: false,
          message: 'Image ID is required'
        })
        return
      }

      logger.info('Starting container image scan', { 
        userId: req.user?.id,
        imageId 
      })

      const result = await ContainerSecurityService.scanContainerImage(imageId)

      res.status(200).json({
        success: true,
        data: result
      })
    } catch (error) {
      logger.error('Container scan endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error during container scan',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Validate infrastructure configuration
   */
  static async validateInfrastructure(req: Request, res: Response): Promise<void> {
    try {
      const { configPath } = req.body

      if (!configPath) {
        res.status(400).json({
          success: false,
          message: 'Configuration path is required'
        })
        return
      }

      logger.info('Starting infrastructure security validation', { 
        userId: req.user?.id,
        configPath 
      })

      const result = await ContainerSecurityService.validateInfrastructureConfiguration(configPath)

      res.status(200).json({
        success: true,
        data: result
      })
    } catch (error) {
      logger.error('Infrastructure validation endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error during infrastructure validation',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Enforce Kubernetes security policies
   */
  static async enforceKubernetesPolicies(req: Request, res: Response): Promise<void> {
    try {
      const { policies } = req.body

      if (!policies || !Array.isArray(policies)) {
        res.status(400).json({
          success: false,
          message: 'Policies array is required'
        })
        return
      }

      logger.info('Enforcing Kubernetes security policies', { 
        userId: req.user?.id,
        policyCount: policies.length 
      })

      const result = await ContainerSecurityService.enforceKubernetesSecurityPolicies(policies)

      res.status(200).json({
        success: result.success,
        data: result
      })
    } catch (error) {
      logger.error('Kubernetes policy enforcement endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error during policy enforcement',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Assess cloud resource security
   */
  static async assessCloudResource(req: Request, res: Response): Promise<void> {
    try {
      const { resourceId, resourceType } = req.body

      if (!resourceId || !resourceType) {
        res.status(400).json({
          success: false,
          message: 'Resource ID and type are required'
        })
        return
      }

      logger.info('Assessing cloud resource security', { 
        userId: req.user?.id,
        resourceId,
        resourceType 
      })

      const result = await ContainerSecurityService.assessCloudResourceSecurity(resourceId, resourceType)

      res.status(200).json({
        success: true,
        data: result
      })
    } catch (error) {
      logger.error('Cloud resource assessment endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error during cloud resource assessment',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Get default security gates configuration
   */
  static async getDefaultSecurityGates(req: Request, res: Response): Promise<void> {
    try {
      const defaultGates = CICDSecurityService.getDefaultSecurityGates()

      res.status(200).json({
        success: true,
        data: defaultGates
      })
    } catch (error) {
      logger.error('Get default security gates endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Update security gate configuration
   */
  static async updateSecurityGate(req: Request, res: Response): Promise<void> {
    try {
      const { gateId } = req.params
      const updates = req.body

      const success = await CICDSecurityService.updateSecurityGate(gateId, updates)

      if (success) {
        res.status(200).json({
          success: true,
          message: 'Security gate updated successfully'
        })
      } else {
        res.status(400).json({
          success: false,
          message: 'Failed to update security gate'
        })
      }
    } catch (error) {
      logger.error('Update security gate endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }

  /**
   * Schedule automated vulnerability scan
   */
  static async scheduleAutomatedScan(req: Request, res: Response): Promise<void> {
    try {
      const { cronExpression } = req.body

      const success = await VulnerabilityService.scheduleAutomatedScan(cronExpression)

      if (success) {
        res.status(200).json({
          success: true,
          message: 'Automated vulnerability scanning scheduled successfully'
        })
      } else {
        res.status(400).json({
          success: false,
          message: 'Failed to schedule automated scanning'
        })
      }
    } catch (error) {
      logger.error('Schedule automated scan endpoint error:', error)
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }
}